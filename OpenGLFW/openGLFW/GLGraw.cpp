#include "GLDraw.h"
#include "Base.h"
#include "Shader.h"
#include "AImage.h"
#include "Camara.h"

GLDraw::GLDraw(int width,int height):width(width),height(height) {
	cam = new Camara();
	cubeShader = new Shader();
	sunShader = new Shader();
	vMatrix = glm::mat4(1.0f);
	pMatrix = glm::mat4(1.0f);
}

GLDraw::~GLDraw() {
	delete cubeShader;
	delete sunShader;
}

void GLDraw::init() {
	// 相机初始化
	glm::vec3 eyes(0.0f, 0.0f, 3.0f);
	glm::vec3 center(0.0f, 0.0f, 1.0f);
	cam->lookAt(eyes, center-eyes , glm::vec3(0.0f, 1.0f, 0.0f));
	cam->setSensitivity(0.1f);


	VAO_cube = createModel();
	VAO_sun = createModel();
	initTexture();

	cubeShader->initShader("vertexShader.glsl", "fragmentShader.glsl");
	sunShader->initShader("vSunShader.glsl", "fSunShader.glsl");
}

void GLDraw::initTexture() {
	img = AImage::loadImage("res/wall.jpg");

	
	glGenTextures(1, &textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);
	// 尺寸超出的时候，采用平铺的模式， s 水平， T 竖直
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	// 缩小的时候取临近像素， 放大的时候取线性插值
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img->getWidth(),img->getHeight(),0,GL_RGBA,GL_UNSIGNED_BYTE,img->getData());
}


uint GLDraw::createModel() {
	/*float vertices[] = {
		0.5f,0.5f,0.0f, 1.0f,0.0f,0.0f,	1.0f,1.0f,
		0.5f,-0.5f,0.0f,  0.0f,1.0f,0.0f,	1.0f,0.0f,
		-0.5f,-0.5f,0.0f,   0.0f,0.0f,1.0f,	0.0f,0.0f,
		-0.5f,0.5f,0.0f,   0.0f,1.0f,0.0f,	0.0f,1.0f, 
	};*/

	uint VAO;
	uint VBO;

	float vertices[] = {
		-0.5f, -0.5f, -0.5f,	0.0f,0.0f,   0.0f,  0.0f, -1.0f,
		 0.5f, -0.5f, -0.5f,	1.0f,0.0f,	 0.0f,  0.0f, -1.0f,
		 0.5f,	0.5f, -0.5f,	1.0f,1.0f,	 0.0f,  0.0f, -1.0f,
		 0.5f,	0.5f, -0.5f,	1.0f,1.0f,	 0.0f,  0.0f, -1.0f,
		-0.5f,	0.5f, -0.5f,	0.0f,1.0f,	 0.0f,  0.0f, -1.0f,
		-0.5f, -0.5f, -0.5f,	0.0f,0.0f,	 0.0f,  0.0f, -1.0f,

		-0.5f, -0.5f,	0.5f,	0.0f,0.0f,	 0.0f,  0.0f,  1.0f,
		 0.5f, -0.5f,	0.5f,	1.0f,0.0f,	 0.0f,  0.0f,  1.0f,
		 0.5f,	0.5f,	0.5f,	1.0f,1.0f,	 0.0f,  0.0f,  1.0f,
		 0.5f,	0.5f,	0.5f,	1.0f,1.0f,	 0.0f,  0.0f,  1.0f,
		-0.5f,	0.5f,	0.5f,	0.0f,1.0f,	 0.0f,  0.0f,  1.0f,
		-0.5f, -0.5f,	0.5f,	0.0f,0.0f,	 0.0f,  0.0f,  1.0f,

		-0.5f,	0.5f,	0.5f,	1.0f,0.0f,	-1.0f,  0.0f,  0.0f,
		-0.5f,	0.5f,  -0.5f,	1.0f,1.0f,	-1.0f,  0.0f,  0.0f,
		-0.5f, -0.5f,  -0.5f,	0.0f,1.0f,	-1.0f,  0.0f,  0.0f,
		-0.5f, -0.5f,  -0.5f,	0.0f,1.0f,	-1.0f,  0.0f,  0.0f,
		-0.5f, -0.5f,	0.5f,	0.0f,0.0f,	-1.0f,  0.0f,  0.0f,
		-0.5f,	0.5f,	0.5f,	1.0f,0.0f,	-1.0f,  0.0f,  0.0f,


		0.5f,	0.5f,	0.5f,	1.0f,0.0f,	 1.0f,  0.0f, 0.0f,
		0.5f,	0.5f,  -0.5f,	1.0f,1.0f,	 1.0f,  0.0f, 0.0f,
		0.5f,  -0.5f,  -0.5f,	0.0f,1.0f,	 1.0f,  0.0f, 0.0f,
		0.5f,  -0.5f,  -0.5f,	0.0f,1.0f,	 1.0f,  0.0f, 0.0f,
		0.5f,  -0.5f,	0.5f,	0.0f,0.0f,	 1.0f,  0.0f, 0.0f,
		0.5f,	0.5f,	0.5f,	1.0f,0.0f,	 1.0f,  0.0f, 0.0f,

		-0.5f, -0.5f,  -0.5f,	0.0f,1.0f,	 0.0f, -1.0f, 0.0f,
		 0.5f, -0.5f,  -0.5f,	1.0f,1.0f,	 0.0f, -1.0f, 0.0f,
		 0.5f, -0.5f,	0.5f,	1.0f,0.0f,	 0.0f, -1.0f, 0.0f,
		 0.5f, -0.5f,	0.5f,	1.0f,0.0f,	 0.0f, -1.0f, 0.0f,
		-0.5f, -0.5f,   0.5f,	0.0f,0.0f,	 0.0f, -1.0f, 0.0f,
		-0.5f, -0.5f,  -0.5f,	0.0f,1.0f,	 0.0f, -1.0f, 0.0f,

		-0.5f,	0.5f,  -0.5f,	0.0f,1.0f,	 0.0f, 1.0f, 0.0f,
		 0.5f,	0.5f,  -0.5f,	1.0f,1.0f,	 0.0f, 1.0f, 0.0f,
		 0.5f,	0.5f,	0.5f,	1.0f,0.0f,	 0.0f, 1.0f, 0.0f,
		 0.5f,	0.5f,	0.5f,	1.0f,0.0f,	 0.0f, 1.0f, 0.0f,
		-0.5f,	0.5f,   0.5f,	1.0f,0.0f,	 0.0f, 1.0f, 0.0f,
		-0.5f,	0.5f,  -0.5f,	0.0f,1.0f,	 0.0f, 1.0f, 0.0f,
	};

	// EBO 模式
	/*int indices[] = {
		0,1,3,
		1,2,3
	};*/
	// VAO 在core 模式下是必须的，在非core 模式下可以不用VAO 接管
	// 使用VAO 的目的是，每个VAO 都能管理一个VBO，如果不使用VAO
	// 那么 后面的VBO 数据会覆盖掉前面的VBO的数据
	glGenVertexArrays(1, &VAO);
	glBindVertexArray(VAO);


	//EBO 相关操作
	/*unsigned int EBO;
	glGenBuffers(1, &EBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);*/
	


	// VBO 程序相关的操作
	// 1, 获取vbo 的index
	glGenBuffers(1, &VBO);

	// 2. 绑定vbo 的index
	glBindBuffer(GL_ARRAY_BUFFER, VBO);

	// 3. 给vbo分配显存空间 传输数据, STATIC_DRAW 告诉GPU 顶点数据不会变动
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	// 4. 告诉shader数据解析方式
	// 参数1： 从哪个位置开始读，锚点，layout 的位置信息
	// 参数2：每次读取多少个
	// 参数3：数据类型
	// 参数4：是否归1化
	// 参数5：步长
	// 参数6：起始地址
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(sizeof(float)*3));
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(sizeof(float)*5));
	//glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(sizeof(float)*6));

	// 5. 激活锚点
	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glEnableVertexAttribArray(2);

	// 解绑VBO、VA0
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
	//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);

	return VAO;
}



void GLDraw::rander() {

	
	cam->update();

	// 设置要清理画布的颜色
	glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
	// 清理画布
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glEnable(GL_DEPTH_TEST);

	// 太阳光的位置
	glm::vec3 lightPos(3.0f,0.0f,-1.0f);
	// 太阳光的强度
	glm::vec3 sunLight(1.0f, 1.0f, 1.0f);
	// 环境光的强度
	float ambientStrength = 0.2f;
	


	// mvp 矩阵变换信息
	vMatrix = cam->getVMatrix(); //glm::lookAt(glm::vec3(0.0, 0.0, 3.0), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));
	pMatrix = glm::perspective(glm::radians(60.0f), float(width) / height, 1.0f, 100.0f);

	glBindTexture(GL_TEXTURE_2D, textureID);


		glm::mat4 mMatrix(1.0f);
		/*mMatrix = glm::translate(mMatrix, glm::vec3(0.0f, 0.0f, 0.0f));
		mMatrix = glm::rotate(mMatrix, glm::radians(20.0f), glm::vec3(0.0f, 1.0f, 0.0f));*/

		// 使用shader 程序
		cubeShader->start();

		// 传入vp 信息
		cubeShader->setMatrix("mMatrix", mMatrix);
		cubeShader->setMatrix("vMatrix", vMatrix);
		cubeShader->setMatrix("pMatrix", pMatrix);

		// 传入光照信息
		cubeShader->setVec3("lightPos", lightPos);
		cubeShader->setVec3("viewPos", cam->getPosition());
		cubeShader->setVec3("sunLight", sunLight);
		cubeShader->setFloat("ambientStrength", ambientStrength);

		//shader->shaderGreenTest();

		// 绑定VAO 主程序
		glBindVertexArray(VAO_cube);


		// 告诉OpenGL 要画一个三角形， 从第0个顶点开始，有效顶点数3个
		glDrawArrays(GL_TRIANGLES, 0, 36);

		// EBO的绘制方式
		//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

		// 解绑shader 程序
		cubeShader->end();

		// 太阳光的位置
		mMatrix = glm::mat4(1.0f);
		mMatrix = glm::translate(mMatrix, glm::vec3(3.0f, 1.0f, -1.0f));
		
		sunShader->start();
		sunShader->setMatrix("mMatrix", mMatrix);
		sunShader->setMatrix("vMatrix", vMatrix);
		sunShader->setMatrix("pMatrix", pMatrix);
		glBindVertexArray(VAO_sun);
		glDrawArrays(GL_TRIANGLES, 0, 36);
		sunShader->end();

	
}

void GLDraw::testDrawCubes() {
	glm::vec3 modelVecs[] = {
		glm::vec3(0.0f,0.0f,0.0f),
		glm::vec3(2.0f,5.0f,-15.0f),
		glm::vec3(-1.5f,-2.2f,-2.5f),
		glm::vec3(-3.8f,-2.0f,-12.3f),
		glm::vec3(2.4f,-0.4f,-3.5f),
		glm::vec3(-1.7f,3.0f,-7.5f),
		glm::vec3(1.3f,-2.0f,-2.5f),
		glm::vec3(1.5f,2.0f,-1.5f),
		glm::vec3(1.5f,0.2f,-1.5f),
		glm::vec3(-1.3f,1.0f,-1.5f),
	};

	// mvp 矩阵变换信息
	vMatrix = cam->getVMatrix(); //glm::lookAt(glm::vec3(0.0, 0.0, 3.0), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));
	pMatrix = glm::perspective(glm::radians(60.0f), float(width) / height, 1.0f, 100.0f);

	glBindTexture(GL_TEXTURE_2D, textureID);

	for (int i = 0; i < 10; ++i)
	{
		glm::mat4 mMatrix(1.0f);
		mMatrix = glm::translate(mMatrix, modelVecs[i]);
		mMatrix = glm::rotate(mMatrix, glm::radians(float(glfwGetTime())*(i + 1) * 5), glm::vec3(0.0f, 1.0f, 0.0f));

		// 使用shader 程序
		cubeShader->start();

		// 传入vp 信息
		cubeShader->setMatrix("mMatrix", mMatrix);
		cubeShader->setMatrix("vMatrix", vMatrix);
		cubeShader->setMatrix("pMatrix", pMatrix);

		//shader->shaderGreenTest();

		// 绑定VAO 主程序
		glBindVertexArray(VAO_cube);


		// 告诉OpenGL 要画一个三角形， 从第0个顶点开始，有效顶点数3个
		glDrawArrays(GL_TRIANGLES, 0, 36);

		// EBO的绘制方式
		//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

		// 解绑shader 程序
		cubeShader->end();

	}
}
